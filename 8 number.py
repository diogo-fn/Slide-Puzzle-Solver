import random

from collections import deque, namedtuple
from operator import eq


class Puzzle(namedtuple("PuzzleFields", ["board", "width", "zero_at"])):
    """
    #The class that represents the puzzle'.
    """
    __slots__ = ()

    def __new__(cls, board, width, zero_at=None):
        if zero_at is None:
            zero_at = board.index(0)

        return super().__new__(cls, board, width, zero_at)

    def solved(self):


        return all(map(eq, self.board, range(1, self.width**2)))

    def actions(self):
        """
       
		Returns a list of displacements, action pairs. move can be only called if a new puzzle results in sliding in the direction of the action.
        """
        at = self.zero_at

        if at >= self.width:
            yield self._move(at - self.width)

        if at + self.width < len(self.board):
            yield self._move(at + self.width)

        if at % self.width:
            yield self._move(at - 1)

        if (at + 1) % self.width:
            yield self._move(at + 1)

    def shuffle(self):
        """
       Returns a puzzle that has been randomly shuffled n times
        """
        puzzle = self
        for _ in range(1000):
            puzzle = random.choice(list(puzzle.actions()))
        return puzzle

    def _move(self, to):
        """
        
		Returns a new puzzle where the number was swapped to a new position
        """
        a, b = min(self.zero_at, to), max(self.zero_at, to)

        board = list(self.board)
        board[a], board[b] = board[b], board[a]

        return Puzzle(tuple(board), self.width, to)

    def print_piece(self):
        for i in range(0, len(self.board), self.width):
            print(self.board[i:i+self.width])


class Node(namedtuple("NodeFields", ["puzzle", "parent"])):
    """
     Class representing the node has the follow attributes
    - 'puzzle' is the  instance of the puzzle
    - 'parent' is a  is the previous node generated by the puzzle
    - 'action' is the action taken, in case its generated
    """
    __slots__ = ()

    def __new__(cls, puzzle, parent=None):
        return super().__new__(cls, puzzle, parent)

    @property
    def action(self):
        if self.parent is None:
            return None

        diff_to_action = {
            +self.puzzle.width: 'Baixo',
            -self.puzzle.width: 'Cima',
            +1: 'Direita',
            -1: 'Esquerda',
        }

        return diff_to_action[self.puzzle.zero_at - self.parent.puzzle.zero_at]


def path(node):
    """
    Reconstructs the Path to the Node
    """
    seen = []
    while node is not None:
        seen.append(node)
        node = node.parent
    return reversed(seen)


def solve(start):
    """
    Searches the right path and gives back the solution as the output, if it exists
    """
    queue = deque([Node(start)])
    seen = {start}

    if start.solved():
        return path(Node(start, None))

    while queue:
        node = queue.pop()

        for move in node.puzzle.actions():
            if move.board not in seen:
                if move.solved():
                    return path(Node(move, node))

                queue.appendleft(Node(move, node))
                seen.add(move.board)


def main():
    board = 1, 0, 3, 4, 2, 6, 7, 5, 8

    puzzle = Puzzle(board, 3)
    puzzle = puzzle.shuffle()
    p = solve(puzzle)
    m = 0
    for node in p:
        print(node.action)

        print('NºDeslocaçações',m)
        node.puzzle.print_piece()
        print()
        m += 1

if __name__ == "__main__":
    main()
